.\" Automatically generated by Pandoc 2.19.2
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "ja (1)" "" "" "" ""
.hy
.SH NAME
.PP
ja - Jacinda: data filtering, processing, reporting
.SH SYNOPSIS
.PP
ja run src.jac -i data.txt
.PP
cat FILE1 FILE2 | ja \[aq]#\[dq]$0\[cq]
.PP
ja tc script.jac
.PP
ja e \[aq]11.67*1.2\[cq]
.SH DESCRIPTION
.PP
\f[B]Jacinda\f[R] is a data stream processing language \[`a] la AWK.
.SH SUBCOMMANDS
.PP
\f[B]run\f[R] - Run a program from file
.PP
\f[B]tc\f[R] - Typecheck a program
.PP
\f[B]e\f[R] - Evaluate an expression (without reference to a file)
.SH OPTIONS
.TP
\f[B]-h\f[R] \f[B]--help\f[R]
Display help
.TP
\f[B]-V\f[R] \f[B]--version\f[R]
Display version information
.TP
\f[B]-I\f[R] \f[B]--include\f[R]
Include directory for imports
.SH LANGUAGE
.SS REGEX
.PP
Regular expressions follow Rust\[cq]s regex library:
https://docs.rs/regex/
.SS BUILTINS
.PP
\f[B]:i\f[R] Postfix operator: parse integer
.PP
\f[B]:f\f[R] Postfix operator: parse float
.PP
\f[B]:\f[R] Postfix operator: parse, inferring type
.PP
\f[B]#\f[R] Prefix operator: tally (count bytes in string)
.TP
\f[B]#*\f[R] Prefix operator: list length
List a -> a
.TP
\f[B],\f[R] Ternary operator: zip with
(a -> b -> c) -> Stream a -> Stream b -> Stream c
.TP
\f[B]|\f[R] Ternary operator: fold
Foldable f :=> (b -> a -> b) -> b -> f a -> b
.TP
\f[B]|>\f[R] Fold without seed
Foldable f :=> (a -> a -> a) -> f a -> a
.TP
\f[B]\[ha]\f[R] Ternary operator: scan
(b -> a -> b) -> b -> Stream a -> Stream b
.TP
\f[B]\[dq]\f[R] Binary operator: map
Functor f :=> a -> b -> f a -> f b
.TP
\f[B][:\f[R] Unary operator: const
a -> b -> a
.TP
\f[B]#.\f[R] Binary operator: filter
Witherable f :=> (a -> Bool) -> f a -> f a
.TP
\f[B]\[rs].\f[R] Binary operator: prior
(a -> a -> b) -> Stream a -> Stream b
.TP
\f[B]\[ti].\f[R] Unary deduplication (stream)
Eq a :=> Stream a -> Stream a
.PP
\f[B]max\f[R] Maximum of two values
.PP
\f[B]min\f[R] Minimum of two values
.PP
\f[B]&\f[R] Boolean and
.PP
\f[B]||\f[R] Boolean or
.PP
\f[B]!\f[R] Prefix boolean not
.TP
\f[B]\[ti]\f[R] Matches regex
Str -> Regex -> Bool
.TP
\f[B]!\[ti]\f[R] Does not match
Str -> Regex -> Bool
.PP
\f[B]ix\f[R] Line number
.TP
\f[B]substr\f[R] Extract substring
Str -> Int -> Int -> Str
.TP
\f[B]split\f[R] Split a string by regex
Str -> Regex -> List Str
.TP
\f[B]splitc\f[R] Split a string on a single character
Str -> Str -> List Str
.TP
\f[B]|.\f[R] Floor function
Float -> Int
.TP
\f[B]|\[ga]\f[R] Ceiling function
Float -> Int
.PP
\f[B]-.\f[R] Unary negate
.PP
\f[B]sprintf\f[R] Convert an expression to a string using the format
string
.TP
\f[B]option\f[R] Option eliminator
b -> (a -> b) -> Option a -> b
.TP
\f[B]match\f[R]
Str -> Regex -> Option (Int .
Int)
.TP
\f[B]\[ti]*\f[R] Match, returning nth capture group
Str -> Int -> Regex -> Option Str
.TP
\f[B]captures\f[R] Return all captures
Str -> Int -> Regex -> List Str
.TP
\f[B]:?\f[R] mapMaybe
Witherable f :=> (a -> Option b) -> f a -> f b
.TP
\f[B].?\f[R] catMaybes
Witherable f :=> f (Option a) -> f a
.PP
\f[B]fp\f[R] Filename
.PP
\f[B]nf\f[R] Number of fields
.SS SYNTAX
.PP
\f[B]\[ga]n\f[R] nth field
.PP
\f[B]\[ga]*\f[R] last field
.PP
\f[B]$n\f[R] nth column
.PP
\f[B]{%<pattern>}{<expr>}\f[R] Filtered stream on lines matching
<pattern>, defined by <expr>
.PP
\f[B]{<expr>}{<expr>}\f[R] Filtered stream defined by <expr>, on lines
satisfying a boolean expression.
.PP
\f[B]{|<expr>}\f[R] Stream defined by <expr>
.PP
\f[B]#t\f[R] Boolean literal
.PP
\f[B]_n\f[R] Negative number
.TP
\f[B].n\f[R] Extract the nth value
List a -> a
.PP
\f[B]->n\f[R] Get the nth element of a tuple
.PP
\f[B]{.\f[R] Line comment
.PP
\f[B]\[at]include\[aq]/path/file.jac\[cq]\f[R] File include
.SH INFLUENTIAL ENVIRONMENT VARIABLES
.PP
\f[V]JAC_PATH\f[R] - colon-separated list of directories to search
.SH EXAMPLES
.TP
[#x>72] #. $0
Print lines longer than 72 bytes
.TP
{#\[ga]0>72}{\[ga]0}
Print lines longer than 72 bytes
.TP
{| sprintf \[aq]%i %i\[aq] (\[ga]2 . \[ga]1)}
Print the first two fields in opposite order
.TP
{ix=3}{\[ga]0}
Select only the third line
.TP
:set fs := /,[ \[rs]t]*|[ \[rs]t]+/; {| sprintf \[aq]%i %i\[aq] (\[ga]2 . \[ga]1)}
Same, with input fields separated by comma and/or blanks and tabs.
.TP
(+)|0 $1:i
Sum first column
.TP
(+)|0 [:1\[dq]$0
Count lines
.TP
[y]|> {|ix}
Count lines
.TP
(+)|0 [#x+1]\[dq]$0
Count bytes (+1 for newlines)
.TP
(+)|0 {|#\[ga]0+1}
Count bytes
.TP
{|sprintf \[aq]%i: %s\[aq] (ix.\[ga]0)}
Display with line numbers
.TP
(&)|#t (>)\[rs]. {|\[ga]1:f}
Is the first column strictly increasing?
.TP
[y]|> {|\[ga]0\[ti]/\[ha]$/}
Is the last line blank?
.SH BUGS
.PP
Please report any bugs you may come across to
https://github.com/vmchale/jacinda/issues
.SH COPYRIGHT
.PP
Copyright 2021-2022.
Vanessa McHale.
All Rights Reserved.
.SH AUTHORS
Vanessa McHale<vamchale@gmail.com>.
