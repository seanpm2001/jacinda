.\" Automatically generated by Pandoc 3.4
.\"
.TH "ja (1)" "" "" ""
.SH NAME
ja \- Jacinda: data filtering, processing, reporting
.SH SYNOPSIS
ja run src.jac \-i data.txt
.PP
cat FILE1 FILE2 | ja \[aq]#\[dq]$0\[aq]
.PP
ja tc script.jac
.PP
ja e \[aq]11.67*1.2\[aq]
.SH DESCRIPTION
\f[B]Jacinda\f[R] is a data stream processing language à la AWK.
.SH SUBCOMMANDS
\f[B]run\f[R] \- Run a program from file
.PP
\f[B]tc\f[R] \- Typecheck a program
.PP
\f[B]e\f[R] \- Evaluate an expression (without reference to a file)
.SH OPTIONS
.TP
\f[B]\-h\f[R] \f[B]\-\-help\f[R]
Display help
.TP
\f[B]\-V\f[R] \f[B]\-\-version\f[R]
Display version information
.TP
\f[B]\-I\f[R] \f[B]\-\-include\f[R]
Include directory for imports
.TP
\f[B]\-F\f[R]
Field separator regex
.TP
\f[B]\-R\f[R]
Record separator regex
.TP
\f[B]\-\-csv\f[R]
Process as CSV
.TP
\f[B]\-Dcount=1\f[R]
Define variable
.SH LANGUAGE
.SS REGEX
Regular expressions follow Rust\[cq]s regex library:
https://docs.rs/regex/
.SS BUILTINS
\f[B]:i\f[R] Postfix operator: parse integer
.PP
\f[B]:f\f[R] Postfix operator: parse float
.PP
\f[B]:\f[R] Postfix operator: parse, inferring type
.PP
\f[B]#\f[R] Prefix operator: tally (count bytes in string)
.TP
\f[B]#*\f[R] Prefix operator: list length
List a \-> a
.TP
\f[B],\f[R] Ternary operator: zip with
(a \-> b \-> c) \-> Stream a \-> Stream b \-> Stream c
.TP
\f[B]|\f[R] Ternary operator: fold
Foldable f :=> (b \-> a \-> b) \-> b \-> f a \-> b
.TP
\f[B]|>\f[R] Fold without seed
Foldable f :=> (a \-> a \-> a) \-> f a \-> a
.TP
\f[B]\[ha]\f[R] Ternary operator: scan
(b \-> a \-> b) \-> b \-> Stream a \-> Stream b
.TP
\f[B]\[dq]\f[R], \f[B]¨\f[R] Binary operator: map
Functor f :=> a \-> b \-> f a \-> f b
.TP
\f[B][:\f[R] Unary operator: const
a \-> b \-> a
.TP
\f[B]#.\f[R] Binary operator: filter
Witherable f :=> (a \-> Bool) \-> f a \-> f a
.TP
\f[B]\[rs].\f[R] Binary operator: prior
(a \-> a \-> b) \-> Stream a \-> Stream b
.TP
\f[B]\[ti].\f[R] Unary deduplication (stream)
Ord a :=> Stream a \-> Stream a
.TP
\f[B]\[ti].*\f[R] Deduplicate on (stream)
Ord b :=> (a \-> b) \-> Stream a \-> Stream a
.TP
\f[B]max\f[R] Maximum of two values
Ord a :=> a \-> a \-> a
.TP
\f[B]min\f[R] Minimum of two values
Ord a :=> a \-> a \-> a
.PP
\f[B]&\f[R] Boolean and
.PP
\f[B]||\f[R] Boolean or
.PP
\f[B]!\f[R] Prefix boolean not
.TP
\f[B]\[ti]\f[R] Matches regex
Str \-> Regex \-> Bool
.TP
\f[B]!\[ti]\f[R] Does not match
Str \-> Regex \-> Bool
.PP
\f[B]ix\f[R], \f[B]⍳\f[R] Line number
.TP
\f[B]substr\f[R] Extract substring
Str \-> Int \-> Int \-> Str
.TP
\f[B]sub1\f[R] Substitute first occurrence
Regex \-> Str \-> Str \-> Str
.TP
\f[B]subs\f[R] Substitute all occurrences
Regex \-> Str \-> Str \-> Str
.TP
\f[B]split\f[R] Split a string by regex
Str \-> Regex \-> List Str
.TP
\f[B]splitc\f[R] Split a string on a single character
Str \-> Str \-> List Str
.TP
\f[B]⌊\f[R], \f[B]|.\f[R] Floor function
Float \-> Int
.TP
\f[B]⌈\f[R], \f[B]|\[ga]\f[R] Ceiling function
Float \-> Int
.PP
\f[B]\-.\f[R] Unary negate
.TP
\f[B]sprintf\f[R] Convert an expression to a string using the format string
\f[B]%f\f[R] float \f[B]%i\f[R] integer \f[B]%s\f[R] string
.TP
\f[B]option\f[R] Option eliminator
b \-> (a \-> b) \-> Option a \-> b
.TP
\f[B]match\f[R]
Str \-> Regex \-> Option (Int .
Int)
.TP
\f[B]\[ti]?\f[R] Maybe match: return string if it is a match, otherwise None
Str \-> Regex \-> Option Str
.TP
\f[B]\[ti]*\f[R] Match, returning nth capture group
Str \-> Int \-> Regex \-> Option Str
.TP
\f[B]captures\f[R] Return all aptures (nth capture group)
Str \-> Int \-> Regex \-> Str
.TP
\f[B]:?\f[R] mapMaybe
Witherable f :=> (a \-> Option b) \-> f a \-> f b
.TP
\f[B].?\f[R] catMaybes
Witherable f :=> f (Option a) \-> f a
.PP
\f[B]fp\f[R] Filename
.PP
\f[B]nf\f[R] Number of fields
.PP
\f[B]⍬\f[R] Empty string/empty list
.TP
\f[B]head#, last#\f[R]
List a \-> a
.TP
\f[B]tail#, init#\f[R]
List a \-> List a
.TP
\f[B]drop#, take#\f[R]
Int \-> List a \-> List a
.SS SYNTAX
\f[B]\[ga]n\f[R] nth field
.PP
\f[B]\[ga]0\f[R] current line
.PP
\f[B]\[ga]*\f[R] last field
.TP
\f[B]\[ga]$\f[R] all fields
List Str
.PP
\f[B]$n\f[R] nth column
.PP
\f[B]$0\f[R] stream of lines
.PP
\f[B]{%<pattern>}{<expr>}\f[R] Filtered stream on lines matching
<pattern>, defined by <expr>
.PP
\f[B]{<expr>}{<expr>}\f[R] Filtered stream defined by <expr>, on lines
satisfying a boolean expression.
.PP
\f[B]{|<expr>}\f[R] Stream defined by <expr>
.PP
\f[B]#t\f[R] Boolean literal
.PP
\f[B]_n\f[R] Negative number
.TP
\f[B].n\f[R] Extract the nth value
List a \-> a
.PP
\f[B]\->n\f[R] Get the nth element of a tuple
.PP
\f[B]{.\f[R] Line comment
.PP
\f[B]\[at]include\[aq]/path/file.jac\[cq]\f[R] File include
.PP
\f[B]?<expr>; <expr>; <expr>\f[R] If\&...
then\&...
else
.PP
\f[B]<pattern>,,<pattern> <expr>\f[R] Bookend a stream
.PP
\f[B]<expr> $> <expr>\f[R] Print stream and summary result
.PP
\f[B]fn f(x, y) := x + y;\f[R] Function definition
.PP
\f[B]let val x := y + 1 in x end\f[R] Let binding
.PP
\f[B](<expr> .
<expr> .
\&...
\&.
<expr>)\f[R] Tuple
.PP
\f[B]#{ <fieldname> .= <expr>; \&...
<fieldname> .= <expr> }\f[R] Record literal
.SS DECLARATIONS
\f[B]:set fs=/REGEX/;\f[R] Set field separator
.PP
\f[B]:set rs=/REGEX/;\f[R] Set record separator
.PP
\f[B]:set csv;\f[R] Process as CSV
.PP
\f[B]:flush;\f[R] Flush stdout for every line
.SH INFLUENTIAL ENVIRONMENT VARIABLES
\f[CR]JAC_PATH\f[R] \- colon\-separated list of directories to search
.SH EXAMPLES
.TP
[#x>72] #. $0
Print lines longer than 72 bytes
.TP
{#\[ga]0>72}{\[ga]0}
Print lines longer than 72 bytes
.TP
{ix=3}{\[ga]0}
Select only the third line
.TP
:set csv; {ix=1}{[x+\[aq]\[rs]n\[aq]+y]|>\[ga]$}
Present column names of a .csv file, one per line
.TP
(+)|0 $1:i
Sum first column
.TP
(+)|0 [:1\[dq]$0
Count lines
.TP
[y]|> {|ix}
Count lines
.TP
(+)|0 [#x+1]\[dq]$0
Count bytes (+1 for newlines)
.TP
(+)|0 {|#\[ga]0+1}
Count bytes
.TP
{|sprintf \[aq]%i: %s\[aq] (ix.\[ga]0)}
Display with line numbers
.TP
(&)|#t (>)\[rs]. {|\[ga]1:f}
Is the first column strictly increasing?
.TP
[y]|> {|\[ga]0\[ti]/\[ha]$/}
Is the last line blank?
.TP
{|option ⍬ [x] (\[ga]0 \[ti]* 1 /\[ha]((\[rs]s+\[rs]S|\[rs]S)*)$/)}
Trim trailing whitespace
.TP
ja \-R\[aq]\[rs]n\[rs]s*\[aq] \[dq][x+\[aq] \[aq]+y]|>\[rs]$0\[dq]
Concatenate into one line, discarding extra leading whitespace between
.SH BUGS
Please report any bugs you may come across to
https://github.com/vmchale/jacinda/issues
.SH COPYRIGHT
Copyright 2021\-2022.
Vanessa McHale.
All Rights Reserved.
.SH AUTHORS
Vanessa McHale\c
.MT vamchale@gmail.com
.ME \c.
